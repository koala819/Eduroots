#!/usr/bin/env node

/**
 * Automatic template repos update script (JavaScript version)
 *
 * This script:
 * 1. Finds all repos created from your template
 * 2. Creates Pull Requests to update them
 * 3. Notifies repo owners
 */

import { Octokit } from '@octokit/rest';

// Configuration
const config = {
  // Template information
  templateOwner: process.env.TEMPLATE_OWNER || 'koala819',
  templateRepo: process.env.TEMPLATE_REPO || 'Eduroots',

  // GitHub token (required) - Use a token with admin permissions
  githubToken: process.env.TOKEN,

  // Branch and PR configuration
  branchName: 'update-from-template',
  prTitle: 'ğŸ”„ Update from template',

  // Files to update from template
  filesToUpdate: [
    'client/components/atoms/PWAButton.tsx',
    'middleware.ts',
    'public/manifest.json',
    'app/sw.ts',
    'package.json',
    'pnpm-lock.yaml',
  ],

  // Repos to update (manual list)
  reposToUpdate: [
    { owner: 'koala819', name: 'Eduroots_COLOMIERS', defaultBranch: 'master', prBaseBranch: 'dev' },
    { owner: 'koala819', name: 'Eduroots_DEMO', defaultBranch: 'master', prBaseBranch: 'dev' },
  ],

  // Pull Request message
  prBody: `
## ğŸ”„ Automatic update from template

This Pull Request updates your repo with the latest changes from the template.

### ğŸ“‹ Included changes:
- âœ… Fixed automatic PWA installation
- âœ… Improved middleware for static files
- âœ… Performance optimizations
- âœ… Support for beforeinstallprompt event

### ğŸš€ Automatic PWA Installation
The \`beforeinstallprompt\` event is now properly handled to trigger native browser installation.

### ğŸ”§ How to test:
1. Click on the "Install application" button
2. Native browser installation should trigger
3. On iOS, manual instructions are displayed

### ğŸ“ Notes:
- This update is compatible with previous versions
- No additional configuration required
- Test in development mode with \`npm run dev\`

### ğŸ”„ Workflow
This PR will be automatically merged to keep your repo in sync with the template.

---

*This PR was automatically generated by the template update script.*
  `.trim(),

  // Advanced options
  options: {
    maxRepos: 100,
    requestDelay: 1000,
    debug: process.env.DEBUG === 'true',
    ignoreErrors: false,
    createIssuesForFailures: false,
    // New option: bypass branch protection
    bypassProtection: process.env.BYPASS_PROTECTION === 'true',
  },
};

class TemplateUpdater {
  constructor() {
    if (!config.githubToken) {
      throw new Error('TOKEN environment variable is required');
    }

    this.config = config;
    this.octokit = new Octokit({
      auth: config.githubToken,
    });
  }

  async run() {
    console.log('ğŸš€ Starting automatic template repos update');
    console.log(`ğŸ“‹ Template: ${this.config.templateOwner}/${this.config.templateRepo}`);
    console.log(`ğŸ”‘ Token configured: ${this.config.githubToken ? 'Yes' : 'No'}`);
    console.log(`ğŸ›¡ï¸ Bypass protection: ${this.config.options.bypassProtection ? 'Yes' : 'No'}`);

    const results = {
      success: [],
      failed: [],
      skipped: [],
    };

    for (const repo of this.config.reposToUpdate) {
      try {
        console.log(`\nğŸ”„ Updating ${repo.owner}/${repo.name}...`);

        const success = await this.updateRepo(repo);

        if (success) {
          results.success.push(repo);
        } else {
          results.skipped.push(repo);
        }

        // Delay between requests
        if (this.config.options.requestDelay > 0) {
          await new Promise(resolve => setTimeout(resolve, this.config.options.requestDelay));
        }
      } catch (error) {
        console.error(`âŒ Error updating ${repo.owner}/${repo.name}:`, error.message);
        results.failed.push({ repo, error: error.message });
      }
    }

    this.printSummary(results);
  }

  async updateRepo(repo) {
    try {
      // Check if repo exists and we have access
      await this.octokit.repos.get({
        owner: repo.owner,
        repo: repo.name,
      });

      // Create or update branch
      await this.createOrUpdateBranch(repo);

      // Update files
      let filesUpdated = false;
      for (const filePath of this.config.filesToUpdate) {
        const updated = await this.updateFile(repo.owner, repo.name, filePath);
        if (updated) filesUpdated = true;
      }

      if (!filesUpdated) {
        console.log(`  â„¹ï¸  No files to update for ${repo.owner}/${repo.name}`);
        return false;
      }

      // Create Pull Request
      const pr = await this.createPullRequest(repo);

      if (pr) {
        console.log(`  âœ… Pull Request created: ${pr.html_url}`);

        // Auto-merge if bypass protection is enabled
        if (this.config.options.bypassProtection) {
          await this.autoMergePullRequest(repo.owner, repo.name, pr.number);
        }

        return true;
      }

      return false;
    } catch (error) {
      if (error.status === 404) {
        console.log(`  âš ï¸  Repo ${repo.owner}/${repo.name} not found or no access`);
      } else {
        throw error;
      }
      return false;
    }
  }

  async createOrUpdateBranch(repo) {
    try {
      // Get the default branch (master or dev)
      const { data: repoData } = await this.octokit.repos.get({
        owner: repo.owner,
        repo: repo.name,
      });

      const defaultBranch = repo.defaultBranch || repoData.default_branch;

      // Get the latest commit from default branch
      const { data: commits } = await this.octokit.repos.listCommits({
        owner: repo.owner,
        repo: repo.name,
        sha: defaultBranch,
        per_page: 1,
      });

      if (commits.length === 0) {
        throw new Error('No commits found in default branch');
      }

      const latestCommitSha = commits[0].sha;

      // Check if our branch already exists
      try {
        await this.octokit.repos.getBranch({
          owner: repo.owner,
          repo: repo.name,
          branch: this.config.branchName,
        });

        // Branch exists, update it
        await this.octokit.git.updateRef({
          owner: repo.owner,
          repo: repo.name,
          ref: `heads/${this.config.branchName}`,
          sha: latestCommitSha,
          force: true,
        });

        console.log(`  ğŸ”„ Branch ${this.config.branchName} updated for ${repo.owner}/${repo.name}`);
      } catch (error) {
        if (error.status === 404) {
          // Branch doesn't exist, create it
          await this.octokit.git.createRef({
            owner: repo.owner,
            repo: repo.name,
            ref: `refs/heads/${this.config.branchName}`,
            sha: latestCommitSha,
          });

          console.log(`  âœ… Branch ${this.config.branchName} created for ${repo.owner}/${repo.name}`);
        } else {
          throw error;
        }
      }
    } catch (error) {
      console.error(`  âŒ Error creating/updating branch:`, error.message);
      throw error;
    }
  }

  async updateFile(owner, repo, filePath) {
    try {
      // Get file content from template
      const { data: templateFile } = await this.octokit.repos.getContent({
        owner: this.config.templateOwner,
        repo: this.config.templateRepo,
        path: filePath,
        ref: 'master',
      });

      // Get current file content in repo
      const { data: currentFile } = await this.octokit.repos.getContent({
        owner,
        repo,
        path: filePath,
        ref: this.config.branchName,
      });

      // Compare contents
      if (templateFile.sha !== currentFile.sha) {
        // Update file
        await this.octokit.repos.createOrUpdateFileContents({
          owner,
          repo,
          path: filePath,
          message: `ğŸ”„ Update ${filePath} from template`,
          content: templateFile.content,
          sha: currentFile.sha,
          branch: this.config.branchName,
        });

        console.log(`  ğŸ“ ${filePath} updated`);
        return true;
      } else {
        console.log(`  âœ… ${filePath} already up to date`);
        return false;
      }
    } catch (error) {
      if (error.status === 404) {
        console.log(`  âš ï¸  ${filePath} doesn't exist in repo`);
        return false;
      } else {
        console.error(`  âŒ Error updating ${filePath}:`, error.message);
        return false;
      }
    }
  }

  async createPullRequest(repo) {
    try {
      // Use prBaseBranch if specified, otherwise default to 'dev' (since master has branch protection)
      const baseBranch = repo.prBaseBranch || 'dev';

      const { data: pr } = await this.octokit.pulls.create({
        owner: repo.owner,
        repo: repo.name,
        title: this.config.prTitle,
        body: this.config.prBody,
        head: this.config.branchName,
        base: baseBranch,
      });

      return pr;
    } catch (error) {
      if (error.status === 422) {
        console.log(`  â„¹ï¸  Pull Request already exists for ${repo.owner}/${repo.name}`);
        return null;
      } else {
        console.error(`  âŒ Error creating Pull Request:`, error.message);
        return null;
      }
    }
  }

  async autoMergePullRequest(owner, repo, prNumber) {
    try {
      // Enable auto-merge
      await this.octokit.pulls.enableAutoMerge({
        owner,
        repo,
        pull_number: prNumber,
        merge_method: 'squash',
      });

      console.log(`  ğŸ”„ Auto-merge enabled for PR #${prNumber}`);

      // Wait a bit then merge
      await new Promise(resolve => setTimeout(resolve, 2000));

      await this.octokit.pulls.merge({
        owner,
        repo,
        pull_number: prNumber,
        merge_method: 'squash',
        commit_title: `ğŸ”„ Auto-merge: Update from template`,
      });

      console.log(`  âœ… PR #${prNumber} auto-merged successfully`);

      // Clean up the branch
      await this.octokit.git.deleteRef({
        owner,
        repo,
        ref: `heads/${this.config.branchName}`,
      });

      console.log(`  ğŸ§¹ Branch ${this.config.branchName} cleaned up`);

    } catch (error) {
      console.error(`  âš ï¸  Auto-merge failed:`, error.message);
    }
  }

  printSummary(results) {
    console.log('\nğŸ“Š Update summary:');
    console.log('==================================================');

    if (results.success.length > 0) {
      console.log(`âœ… Success: ${results.success.length}`);
      for (const repo of results.success) {
        console.log(`  - ${repo.owner}/${repo.name}`);
      }
    }

    if (results.skipped.length > 0) {
      console.log(`â­ï¸  Skipped: ${results.skipped.length}`);
      for (const repo of results.skipped) {
        console.log(`  - ${repo.owner}/${repo.name} (no changes)`);
      }
    }

    if (results.failed.length > 0) {
      console.log(`âŒ Failed: ${results.failed.length}`);
      for (const { repo, error } of results.failed) {
        console.log(`  - ${repo.owner}/${repo.name}: ${error}`);
      }
    }

    const total = results.success.length + results.skipped.length + results.failed.length;
    console.log(`\nğŸ‰ Update completed! ${results.success.length}/${total} repos updated`);
  }
}

// Main execution
async function main() {
  try {
    const updater = new TemplateUpdater();
    await updater.run();
  } catch (error) {
    console.error('âŒ Script failed:', error.message);
    process.exit(1);
  }
}

main();
