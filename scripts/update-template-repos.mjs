#!/usr/bin/env node

/**
 * Automatic template repos update script (JavaScript version)
 *
 * This script:
 * 1. Finds all repos created from your template
 * 2. Creates Pull Requests to update them
 * 3. Notifies repo owners
 */

import { Octokit } from '@octokit/rest';

// Configuration
const config = {
  // Template information
  templateOwner: process.env.TEMPLATE_OWNER || 'koala819',
  templateRepo: process.env.TEMPLATE_REPO || 'Eduroots',

  // GitHub token (required) - Use a token with admin permissions
  githubToken: process.env.TOKEN,

  // Branch and PR configuration
  branchName: 'update-from-template',
  prTitle: 'ğŸ”„ Update from template',

  // Files to exclude from automatic sync (fichiers spÃ©cifiques Ã  chaque instance)
  filesToExclude: [
    '.env',
    '.env.local',
    '.env.production',
    'node_modules/**',
    '.next/**',
    '.git/**',
    'utils/**', // Dossiers spÃ©cifiques Ã  chaque instance
    'db_migration/**',
    'docker/**',
    'scripts/**', // Scripts de mise Ã  jour (ne doivent pas Ãªtre copiÃ©s)
    '.github/workflows/update-template-repos.yml', // Workflow de mise Ã  jour lui-mÃªme
    'public/Logo.jpg', // Assets spÃ©cifiques Ã  chaque instance
  ],

  // Repos to update (manual list)
  reposToUpdate: [
    { owner: 'koala819', name: 'Eduroots_COLOMIERS', defaultBranch: 'master', prBaseBranch: 'dev' },
    { owner: 'koala819', name: 'Eduroots_DEMO', defaultBranch: 'master', prBaseBranch: 'dev' },
  ],

  // Pull Request message
  prBody: `
## ğŸ”„ Automatic update from template

This Pull Request updates your repo with the latest changes from the template.

### ğŸ“‹ Included changes:
- âœ… Fixed automatic PWA installation
- âœ… Improved middleware for static files
- âœ… Performance optimizations
- âœ… Support for beforeinstallprompt event

### ğŸš€ Automatic PWA Installation
The \`beforeinstallprompt\` event is now properly handled to trigger native browser installation.

### ğŸ”§ How to test:
1. Click on the "Install application" button
2. Native browser installation should trigger
3. On iOS, manual instructions are displayed

### ğŸ“ Notes:
- This update is compatible with previous versions
- No additional configuration required
- Test in development mode with \`npm run dev\`

### ğŸ”„ Workflow
This PR will be automatically merged to keep your repo in sync with the template.

---

*This PR was automatically generated by the template update script.*
  `.trim(),

  // Advanced options
  options: {
    maxRepos: 100,
    requestDelay: 1000,
    debug: process.env.DEBUG === 'true',
    ignoreErrors: false,
    createIssuesForFailures: false,
    // New option: bypass branch protection
    bypassProtection: process.env.BYPASS_PROTECTION === 'true',
  },
};

class TemplateUpdater {
  constructor() {
    if (!config.githubToken) {
      throw new Error('TOKEN environment variable is required');
    }

    this.config = config;
    this.octokit = new Octokit({
      auth: config.githubToken,
    });
  }

  async run() {
    console.log('ğŸš€ Starting automatic template repos update');
    console.log(`ğŸ“‹ Template: ${this.config.templateOwner}/${this.config.templateRepo}`);
    console.log(`ğŸ”‘ Token configured: ${this.config.githubToken ? 'Yes' : 'No'}`);
    console.log(`ğŸ›¡ï¸ Bypass protection: ${this.config.options.bypassProtection ? 'Yes' : 'No'}`);

    const results = {
      success: [],
      failed: [],
      skipped: [],
    };

    for (const repo of this.config.reposToUpdate) {
      try {
        console.log(`\nğŸ”„ Updating ${repo.owner}/${repo.name}...`);

        const success = await this.updateRepo(repo);

        if (success) {
          results.success.push(repo);
        } else {
          results.skipped.push(repo);
        }

        // Delay between requests
        if (this.config.options.requestDelay > 0) {
          await new Promise(resolve => setTimeout(resolve, this.config.options.requestDelay));
        }
      } catch (error) {
        console.error(`âŒ Error updating ${repo.owner}/${repo.name}:`, error.message);
        results.failed.push({ repo, error: error.message });
      }
    }

    this.printSummary(results);
  }

  // RÃ©cupÃ©rer rÃ©cursivement tous les fichiers d'un rÃ©pertoire
  async getAllFiles(owner, repo, path = '', ref = 'dev') {
    const files = [];

    try {
      const { data: contents } = await this.octokit.repos.getContent({
        owner,
        repo,
        path: path || '.',
        ref,
      });

      // Si c'est un tableau (rÃ©pertoire)
      if (Array.isArray(contents)) {
        for (const item of contents) {
          if (item.type === 'file') {
            // VÃ©rifier si le fichier doit Ãªtre exclu
            const shouldExclude = this.config.filesToExclude.some(exclude => {
              // Convertir le pattern en regex
              // ** correspond Ã  n'importe quel chemin
              // * correspond Ã  n'importe quel nom de fichier/rÃ©pertoire
              let pattern = exclude
                .replace(/\./g, '\\.') // Ã‰chapper les points
                .replace(/\*\*/g, '.*') // ** devient .*
                .replace(/\*/g, '[^/]*'); // * devient [^/]*

              const regex = new RegExp(`^${pattern}$`);
              return regex.test(item.path);
            });

            if (!shouldExclude) {
              files.push(item.path);
            }
          } else if (item.type === 'dir') {
            // VÃ©rifier si le rÃ©pertoire doit Ãªtre exclu
            const shouldExcludeDir = this.config.filesToExclude.some(exclude => {
              let pattern = exclude
                .replace(/\./g, '\\.')
                .replace(/\*\*/g, '.*')
                .replace(/\*/g, '[^/]*');

              const regex = new RegExp(`^${pattern}$`);
              return regex.test(item.path) || item.path.startsWith(exclude.replace(/\*\*/g, ''));
            });

            if (!shouldExcludeDir) {
              // RÃ©cursion pour les sous-rÃ©pertoires
              const subFiles = await this.getAllFiles(owner, repo, item.path, ref);
              files.push(...subFiles);
            }
          }
        }
      } else if (contents.type === 'file') {
        // Si c'est un fichier unique
        const shouldExclude = this.config.filesToExclude.some(exclude => {
          // Convertir le pattern en regex
          let pattern = exclude
            .replace(/\./g, '\\.') // Ã‰chapper les points
            .replace(/\*\*/g, '.*') // ** devient .*
            .replace(/\*/g, '[^/]*'); // * devient [^/]*

          const regex = new RegExp(`^${pattern}$`);
          return regex.test(contents.path);
        });

        if (!shouldExclude) {
          files.push(contents.path);
        }
      }
    } catch (error) {
      if (error.status !== 404) {
        console.error(`  âš ï¸  Error getting files from ${path}:`, error.message);
      }
    }

    return files;
  }

  async updateRepo(repo) {
    try {
      // Check if repo exists and we have access
      await this.octokit.repos.get({
        owner: repo.owner,
        repo: repo.name,
      });

      // Create or update branch
      await this.createOrUpdateBranch(repo);

      // RÃ©cupÃ©rer automatiquement tous les fichiers du template
      console.log(`  ğŸ” Scanning template files...`);
      const templateFiles = await this.getAllFiles(
        this.config.templateOwner,
        this.config.templateRepo,
        '',
        'dev'
      );
      console.log(`  ğŸ“‹ Found ${templateFiles.length} files in template`);

      // Update files
      let filesUpdated = 0;
      let filesSkipped = 0;
      let filesError = 0;

      for (const filePath of templateFiles) {
        const result = await this.updateFile(repo.owner, repo.name, filePath);
        if (result === 'updated') {
          filesUpdated++;
        } else if (result === 'skipped') {
          filesSkipped++;
        } else {
          filesError++;
        }
      }

      console.log(`  ğŸ“Š Summary: ${filesUpdated} updated, ${filesSkipped} skipped, ${filesError} errors`);

      if (filesUpdated === 0) {
        console.log(`  â„¹ï¸  No files to update for ${repo.owner}/${repo.name}`);
        return false;
      }

      // Create Pull Request
      const pr = await this.createPullRequest(repo);

      if (pr) {
        console.log(`  âœ… Pull Request created: ${pr.html_url}`);

        // Auto-merge if bypass protection is enabled
        if (this.config.options.bypassProtection) {
          await this.autoMergePullRequest(repo.owner, repo.name, pr.number);
        }

        return true;
      }

      return false;
    } catch (error) {
      if (error.status === 404) {
        console.log(`  âš ï¸  Repo ${repo.owner}/${repo.name} not found or no access`);
      } else {
        throw error;
      }
      return false;
    }
  }

  async createOrUpdateBranch(repo) {
    try {
      // Use dev branch as source (since PRs go to dev, not master)
      // This avoids workflow rules that block branches created from master
      const sourceBranch = repo.prBaseBranch || 'dev';

      // Get the latest commit from source branch (dev)
      const { data: commits } = await this.octokit.repos.listCommits({
        owner: repo.owner,
        repo: repo.name,
        sha: sourceBranch,
        per_page: 1,
      });

      if (commits.length === 0) {
        throw new Error('No commits found in default branch');
      }

      const latestCommitSha = commits[0].sha;

      // Check if our branch already exists
      try {
        await this.octokit.repos.getBranch({
          owner: repo.owner,
          repo: repo.name,
          branch: this.config.branchName,
        });

        // Branch exists, update it
        await this.octokit.git.updateRef({
          owner: repo.owner,
          repo: repo.name,
          ref: `heads/${this.config.branchName}`,
          sha: latestCommitSha,
          force: true,
        });

        console.log(`  ğŸ”„ Branch ${this.config.branchName} updated for ${repo.owner}/${repo.name}`);
      } catch (error) {
        if (error.status === 404) {
          // Branch doesn't exist, create it
          await this.octokit.git.createRef({
            owner: repo.owner,
            repo: repo.name,
            ref: `refs/heads/${this.config.branchName}`,
            sha: latestCommitSha,
          });

          console.log(`  âœ… Branch ${this.config.branchName} created for ${repo.owner}/${repo.name}`);
        } else {
          throw error;
        }
      }
    } catch (error) {
      console.error(`  âŒ Error creating/updating branch:`, error.message);
      throw error;
    }
  }

  async updateFile(owner, repo, filePath) {
    try {
      // Get file content from template (use dev branch where changes are made)
      const { data: templateFile } = await this.octokit.repos.getContent({
        owner: this.config.templateOwner,
        repo: this.config.templateRepo,
        path: filePath,
        ref: 'dev',
      });

      if (templateFile.type !== 'file') {
        return 'skipped';
      }

      // Get current file content in repo (try branch first, then default branch)
      let currentFile = null;
      let currentSha = null;

      try {
        const { data } = await this.octokit.repos.getContent({
          owner,
          repo,
          path: filePath,
          ref: this.config.branchName,
        });
        currentFile = data;
        currentSha = data.sha;
      } catch (error) {
        if (error.status === 404) {
          // File doesn't exist in branch, try default branch
          try {
            const { data } = await this.octokit.repos.getContent({
              owner,
              repo,
              path: filePath,
              ref: 'dev', // ou master selon la config
            });
            currentFile = data;
            currentSha = data.sha;
          } catch (e) {
            // File doesn't exist at all, we'll create it
            currentSha = null;
          }
        } else {
          throw error;
        }
      }

      // Compare contents
      if (templateFile.sha !== currentSha) {
        // Update or create file
        await this.octokit.repos.createOrUpdateFileContents({
          owner,
          repo,
          path: filePath,
          message: `ğŸ”„ Update ${filePath} from template`,
          content: templateFile.content,
          sha: currentSha, // null si le fichier n'existe pas
          branch: this.config.branchName,
        });

        if (currentSha) {
          console.log(`  ğŸ“ ${filePath} updated`);
        } else {
          console.log(`  â• ${filePath} created`);
        }
        return 'updated';
      } else {
        if (this.config.options.debug) {
          console.log(`  âœ… ${filePath} already up to date`);
        }
        return 'skipped';
      }
    } catch (error) {
      if (error.status === 404) {
        if (this.config.options.debug) {
          console.log(`  âš ï¸  ${filePath} doesn't exist in template or repo`);
        }
        return 'skipped';
      } else {
        console.error(`  âŒ Error updating ${filePath}:`, error.message);
        return 'error';
      }
    }
  }

  async createPullRequest(repo) {
    try {
      // Use prBaseBranch if specified, otherwise default to 'dev' (since master has branch protection)
      const baseBranch = repo.prBaseBranch || 'dev';

      const { data: pr } = await this.octokit.pulls.create({
        owner: repo.owner,
        repo: repo.name,
        title: this.config.prTitle,
        body: this.config.prBody,
        head: this.config.branchName,
        base: baseBranch,
      });

      return pr;
    } catch (error) {
      if (error.status === 422) {
        console.log(`  â„¹ï¸  Pull Request already exists for ${repo.owner}/${repo.name}`);
        return null;
      } else {
        console.error(`  âŒ Error creating Pull Request:`, error.message);
        return null;
      }
    }
  }

  async autoMergePullRequest(owner, repo, prNumber) {
    try {
      // Enable auto-merge
      await this.octokit.pulls.enableAutoMerge({
        owner,
        repo,
        pull_number: prNumber,
        merge_method: 'squash',
      });

      console.log(`  ğŸ”„ Auto-merge enabled for PR #${prNumber}`);

      // Wait a bit then merge
      await new Promise(resolve => setTimeout(resolve, 2000));

      await this.octokit.pulls.merge({
        owner,
        repo,
        pull_number: prNumber,
        merge_method: 'squash',
        commit_title: `ğŸ”„ Auto-merge: Update from template`,
      });

      console.log(`  âœ… PR #${prNumber} auto-merged successfully`);

      // Clean up the branch
      await this.octokit.git.deleteRef({
        owner,
        repo,
        ref: `heads/${this.config.branchName}`,
      });

      console.log(`  ğŸ§¹ Branch ${this.config.branchName} cleaned up`);

    } catch (error) {
      console.error(`  âš ï¸  Auto-merge failed:`, error.message);
    }
  }

  printSummary(results) {
    console.log('\nğŸ“Š Update summary:');
    console.log('==================================================');

    if (results.success.length > 0) {
      console.log(`âœ… Success: ${results.success.length}`);
      for (const repo of results.success) {
        console.log(`  - ${repo.owner}/${repo.name}`);
      }
    }

    if (results.skipped.length > 0) {
      console.log(`â­ï¸  Skipped: ${results.skipped.length}`);
      for (const repo of results.skipped) {
        console.log(`  - ${repo.owner}/${repo.name} (no changes)`);
      }
    }

    if (results.failed.length > 0) {
      console.log(`âŒ Failed: ${results.failed.length}`);
      for (const { repo, error } of results.failed) {
        console.log(`  - ${repo.owner}/${repo.name}: ${error}`);
      }
    }

    const total = results.success.length + results.skipped.length + results.failed.length;
    console.log(`\nğŸ‰ Update completed! ${results.success.length}/${total} repos updated`);
  }
}

// Main execution
async function main() {
  try {
    const updater = new TemplateUpdater();
    await updater.run();
  } catch (error) {
    console.error('âŒ Script failed:', error.message);
    process.exit(1);
  }
}

main();
